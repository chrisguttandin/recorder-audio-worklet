// This is the minified and stringified code of the recorder-audio-worklet-processor package.
export const worklet = `(()=>{"use strict";class e extends AudioWorkletProcessor{constructor(){super(),this._encoderPort=null,this._state="inactive",this.port.onmessage=({data:e})=>{"record"===e.method?"inactive"===this._state?(this._encoderPort=e.params.encoderPort,this._state="active",this.port.postMessage({id:e.id,result:null})):this.port.postMessage({error:{code:-32603,message:"The internal state does not allow to process the given message."},id:e.id}):"stop"===e.method?"active"!==this._state&&"recording"!==this._state||null===this._encoderPort?this.port.postMessage({error:{code:-32603,message:"The internal state does not allow to process the given message."},id:e.id}):(this._stop(this._encoderPort),this.port.postMessage({id:e.id,result:null})):"number"==typeof e.id&&this.port.postMessage({error:{code:-32601,message:"The requested method is not supported."},id:e.id})}}process([e]){if("inactive"===this._state)return!0;if("active"===this._state){if(void 0===e)throw new Error("No channelData was received for the first input.");if(0===e.length)return!0;this._state="recording"}if("recording"===this._state&&null!==this._encoderPort){if(void 0===e)throw new Error("No channelData was received for the first input.");if(0!==e.length)return this._encoderPort.postMessage(e,e.map((({buffer:e})=>e))),!0;this._stop(this._encoderPort)}return!1}_stop(e){e.postMessage([]),e.close(),this._encoderPort=null,this._state="stopped"}}e.parameterDescriptors=[],registerProcessor("recorder-audio-worklet-processor",e)})();`; // tslint:disable-line:max-line-length
